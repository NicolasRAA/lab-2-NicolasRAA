# Лабораторная работа № 2

## Содержание
1. [Введение](#Intro)
2. [Решения](#Solutions)
     1. [Первая часть](#part1)
     2. [Задача на разминку](#warmup)
     3. [Задание лабораторной работы](#exlab)
3. [Заключение](#Conclusion)


## Введение <a name="Intro"></a>

В данной лабораторной работе я продолжил изучение bash как языка программирования. В частности, я применил навыки работы с переменными, условными операторами и аргументами командной строки для решения следующих задач:
  * Проверка значения аргумента и выполнение вычислений.
  * Решение арифметических задач с двумя аргументами.
  * Преобразование IPv4-адреса из десятичного формата в двоичный.

## Решение <a name="Solutions"></a>

### Первая часть <a name="part1"></a>

Шаги выполнения:
1. **Создание репозитория и скрипта**
  Сначала создал новый репозиторий на GitHub:
  ```bash
  gh repo create NicolasRAA/lab-2-NicolasRAA --public ----description "Lab 2 informatics ac. d"
  ```
  Клонировал его, и переместился в этот каталог с помощью `cd`:  
  ![git clone y cd lab-2-NicolasRAA](https://github.com/user-attachments/assets/4dc290d4-051f-46e8-ae49-1bac724b99af)
  Cоздал файл `script.bash` коммандой `gedit script.bash`.
  
2. **Объявление переменной и проверка значения**
  В этом шаге я объявил переменную `a` и присвоил ей значение первого аргумента, переданного в скрипт.  
  ![Variable a](https://github.com/user-attachments/assets/bd6f819b-dd1f-49d4-82fa-19f4b1c1374f)  
  После этого проверил, равно ли значение переменной a числу 23, с помощью условной конструкции if.  
  ![paso 4 verificar si a vale 23](https://github.com/user-attachments/assets/ef2d192c-ef40-4f3a-8e17-441e7c447843)  
  Если переменная `a` равна 23, скрипт выведет сообщение "`Modify me!`". В противном случае, скрипт напечатает "`$a is not "23"`", как показано в примере ниже, где я использовал команду `bash script.bash` с переменной `23`.  
  ![bash script bash 23](https://github.com/user-attachments/assets/c1cb851b-6067-452d-af95-8aed48bca1ed)
  
3. **Модификация переменной и вывод результата**  
   Если значение переменной равно 23, к числу добавляется 19, и результат выводится в стандартный вывод.  
   ![gedit script bash a+19](https://github.com/user-attachments/assets/02d89548-466d-48bc-92c7-5e6217e65255)  
   Потом я протестировал скрипт с значениями 23 и 10 для переменной `a`.  
   ![bash script bash a 23 y a 10](https://github.com/user-attachments/assets/7816aa72-9718-4e65-b5e3-323f2e1b26d1)  

---
### Задача на разминку <a name="warmup"></a>  
В этой задаче я был обязан написать скрипт, который на вход принимает два целых числа и выводит их сумму, разницу и произведение.  
  
Шаги выполнения:  
1.  Открил скрипт с помощью команды `gedit script.bash` и оформил новый код в нём.
   ![codigo ejercicio de calentamiento](https://github.com/user-attachments/assets/b8a0cb57-f153-40f7-94ee-10e10787a81a)  
    Код работает следующим образом:
    *  В первой строке скрипт принимает два аргумента: `x` и `y`.
    *  Переменная `sum` вычисляет сумму двух чисел: `$(($x + $y))`.
    *  Переменная `difference` вычисляет разность: `$(($x - $y))`.
    *  Переменная `product` вычисляет произведение числа: `$(($x * $y))`.

2. Потом я протестировал скрипт со значениями `5` и `3`.
   ![bash script bash 5 3](https://github.com/user-attachments/assets/ecf62585-6553-4b90-b692-3a267a298187)
   Получены правильные результаты:
     * `5` + `3` = `8`
     * `5` - `3` = `2`
     * `5` * `3` = `15`
       
3. Потом с помощью команды `git add` `git commit` и `git push` я добавил этот скрипт в мой github:
  ```bash
  git add script.bash
  git commit -m "Adding script for finding the sum, differece and product of 2 numbers"
  git push origin main
  ```

---
### Задание лабораторной работы <a name="exlab"></a>
  Для задания я должен был разработать скрипт для преобразования IPv4-адреса в десятичном формате в двоичный формат. 
    
Шаги выполнения:  
1.  Открил скрипт с помощью команды `gedit script.bash` и оформил новый код в нём.
   ![script ej lab](https://github.com/user-attachments/assets/b94a96d4-6451-4edf-a38c-593ea240aa15)
    Код работает следующим образом:
    * Если пользователь передает неправильное количество аргументов (не один), скрипт выводит сообщение об использовании и завершает выполнение с кодом ошибки `1`.
    * Переменная `ip` получает значение первого аргумента. С помощью `IFS='.' read` IP-адрес разбивается на четыре октета: `oct1`, `oct2`, `oct3`, `oct4`.
    * Каждый октет преобразуется в 8-битное двоичное число с помощью комбинации `bc` (арифметический калькулятор) и `printf`:  
        * `bc <<< "obase=2; $oct1"` переводит число в двоичный формат.
        * `printf "%08d"` дополняет результат до 8 цифр, если нужно.
    * Скрипт объединяет преобразованные октеты через точку и выводит результат в формате `xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx`.
      
2. Я протестировал скрипт как показано в картинке ниже:  
   ![Probando el script con ips diferentes](https://github.com/user-attachments/assets/e2e222d1-549e-4688-bd64-294ebb67a8c9)
   *Этот скрипт полезен для анализа сетевых адресов и их преобразования в бинарный вид, что часто требуется в вычислительных сетях.*

3. Для проверки полученных результатов, я здесь "вручную" преобразовал IP-адреса в двоичные:
     * Пример 1: IPv4-адрес `192.168.10.1`
         * Разбиваю  IP-адрес на октеты: `192`, `168`, `10`, `1`.
         * Переоброзую каждый октет в двоичный формат:
             * Октет `192`:
                 * Я делю число на 2 и записываю остатки справа налево:
                   ```
                   192 ÷ 2 = 96, остаток 0  
                   96 ÷ 2 = 48, остаток 0  
                   48 ÷ 2 = 24, остаток 0  
                   24 ÷ 2 = 12, остаток 0  
                   12 ÷ 2 = 6, остаток 0  
                   6 ÷ 2 = 3, остаток 0  
                   3 ÷ 2 = 1, остаток 1  
                   1 ÷ 2 = 0, остаток 1  
                   ```
                * Двоичный результат: `11000000`.  
             * Октет `168`:
                  ```
                  168 ÷ 2 = 84, остаток 0  
                  84 ÷ 2 = 42, остаток 0  
                  42 ÷ 2 = 21, остаток 0  
                  21 ÷ 2 = 10, остаток 1  
                  10 ÷ 2 = 5, остаток 0  
                  5 ÷ 2 = 2, остаток 1  
                  2 ÷ 2 = 1, остаток 0  
                  1 ÷ 2 = 0, остаток 1
                  ```
                * Двоичный результат: `10101000`.  
             * Октет `10`:
                  ```
                  10 ÷ 2 = 5, остаток 0  
                  5 ÷ 2 = 2, остаток 1  
                  2 ÷ 2 = 1, остаток 0  
                  1 ÷ 2 = 0, остаток 1
                  ```
                * Двоичный результат: `00001010` (дополнил до 8 бит).  
             * Октет `1`:
                  ```
                  1 ÷ 2 = 0, остаток 1  
                  ```
                * Двоичный результат: `00000001` (дополнил до 8 бит).  
         * Результат: `192.168.10.1` → `11000000.10101000.00001010.00000001`.
      
     * Пример 2: IPv4-адрес `10.0.0.1`
         * Разбиваю  IP-адрес на октеты: `10`, `0`, `0`, `1`.
         * Переоброзую каждый октет в двоичный формат:
             * Октет `10`:  
                  ```
                  10 ÷ 2 = 5, остаток 0  
                  5 ÷ 2 = 2, остаток 1  
                  2 ÷ 2 = 1, остаток 0  
                  1 ÷ 2 = 0, остаток 1
                  ```
                * Двоичный результат: `00001010` (дополнили до 8 бит).  
             * Октет `0`:  
                  `0` в двоичном формате — это `00000000`.  
             * Октет `1`:
                  ```
                  1 ÷ 2 = 0, остаток 1  
                  ```
                * Двоичный результат: 00000001 (дополнили до 8 бит).  
         * Результат: `10.0.0.1` → `00001010.00000000.00000000.00000001`.  

Результаты, которые я получил вручную, совпадают с результатами скрипта. Так что можно сказать, что скрипт работает корректно! 😊

4. Потом с помощью команды `git add` `git commit` и `git push` я добавил этот отредактированный скрипт в мой github:  
   ![git add commit y push](https://github.com/user-attachments/assets/d8403b7d-1b89-4b60-9a84-6bbd983ece9b)  

5. Я зашел на github, чтобы убедиться, что скрипт там есть, и действительно, последняя версия уже была там.  
   ![Second task en github](https://github.com/user-attachments/assets/6da7612d-6cbf-4aea-8b5e-60c9b3caff2d)  

6. Напоследок я создал README.md в терминале linux с помощью команды `gedit README.md`, а затем загрузил его на свой github с помощью вышеупомянутых команд, чтобы потом отредоктировать и доделать его уже в github.  
   ![Creando y agregando el README](https://github.com/user-attachments/assets/078a509e-0ee0-48a1-b217-8caabdcd09dc)

---
## Заключение <a name="Conclusion"></a> 
В результате выполнения лабораторной работы я углубил свои знания по работе с Bash-скриптами и научился использовать различные команды для обработки аргументов, выполнения математических операций и преобразования данных. Также я закрепил навыки работы с Git и GitHub для управления проектами.

